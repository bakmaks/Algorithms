
def segments_covered_with_dots():
    """
    Необходимо найти множество точек, для которого каждый из отрезков, лежащих на прямой,
    (отрезки могут лежать друг на друге) содержит хотя бы одну из точек
    (не обязательно точка должна лежать на каждом отрезке сразу)
    и размер множества был бы минимальным.

    :return:
    """
    print('Введите кол-во строк:')
    seg_numbers = int(input())
    seg_list = []
    print('Введите отрезок:')
    for i in range(seg_numbers):
        key = sorted(map(int, input().split(' ')))
        seg_list.append(key)                        # Список отрезков
    seg_list.sort(key=lambda x: x[1])               # Отрезки сортируются по правым концам
    dots = [seg_list.pop(0)[1]]                     # выбирается правая точка первого отрезка
    for left_dot, right_dot in seg_list:            # Выбираем левый и правый концы отрезка
        # Если точка меньше левого конца отрезка то она заносится во множество.
        # Отрезки были упорядочены по правым концам, соответсвенно - если правая точка первого отрезка
        # больше чем левые концы последующих отрезков, значит она также будет лежать
        # и на них. Как только она становится меньше чем левый конец следующего отрезка,
        # правая точка этого отрезка заносится во множество и т. д.
        if dots[-1] < left_dot:
            dots.append(right_dot)
    print(len(dots))
    print(' '.join(list(map(str, dots))))

# Примеры работы
# Sample Input 1:
#
# 3    Кол-во отрезков.
# 1 3
# 2 5
# 3 6
# Sample Output 1:
#
# 1     Кол-во точек во множестве
# 3     Сами точки

# Sample Input 2:
#
# 4     Кол-во отрезков
# 4 7
# 1 3
# 2 5
# 5 6
# Sample Output 2:
#
# 2     Кол-во точек во множестве
# 3 6   Сами точки
#-----------------------------------------------------------------------------------------------------------------

def continuous_backpack():
    """
    Первая строка содержит количество предметов и вместимость рюкзака.
    Каждая из следующих n строк задаёт стоимость и объём предмета (все числа целые).
    Выведите максимальную стоимость частей предметов (от каждого предмета можно отделить любую часть,
    стоимость и объём при этом пропорционально уменьшатся), помещающихся в данный рюкзак,
    с точностью не менее трёх знаков после запятой.
    :return:
    """
    N, W = map(int, input('Введите чере пробел кол-во предметов и вместимость рюкзака: ').split())
    L = []
    for i in range(N):
        c, w = map(int, input('Введите чере пробел стоимось предмета и объём:').split())
        if w == 0:
            c, w = 0, 0
        L.append([c/w, w])
    max_cost = 0
    L.sort(key=lambda x: x[0], reverse=True)
    for thing in L:
        if W > thing[1]:
            max_cost += thing[0] * thing[1]
            W -= thing[1]
        else:
            max_cost += W * thing[0]
            break
    print('{0:.3f}'.format(max_cost))

if __name__ == '__main__':
    # segments_covered_with_dots()
    continuous_backpack()